<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets\app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:12,&quot;tests&quot;:12,&quot;passes&quot;:8,&quot;pending&quot;:0,&quot;failures&quot;:4,&quot;testsRegistered&quot;:12,&quot;passPercent&quot;:66.66666666666667,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false,&quot;start&quot;:&quot;2023-11-12T14:14:30.917Z&quot;,&quot;end&quot;:&quot;2023-11-12T15:05:56.542Z&quot;,&quot;duration&quot;:3085625},&quot;results&quot;:[{&quot;uuid&quot;:&quot;5dc78145-ab7d-4153-9361-2dd801f58b42&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\darazAddCart.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\darazAddCart.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;b53e0932-07ca-4cd3-a268-3abe093f7324&quot;,&quot;title&quot;:&quot;Daraz - Add To Cart Feature&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Verify Add To Cart Feature in Daraz&quot;,&quot;fullTitle&quot;:&quot;Daraz - Add To Cart Feature Verify Add To Cart Feature in Daraz&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:11755,&quot;state&quot;:&quot;failed&quot;,&quot;speed&quot;:null,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;CypressError: `cy.wait()` could not find a registered alias for: `@12000`.\nYou have not aliased anything yet.&quot;,&quot;estack&quot;:&quot;CypressError: `cy.wait()` could not find a registered alias for: `@12000`.\nYou have not aliased anything yet.\n    at $Cy.aliasNotFoundFor (https://member.daraz.pk/__cypress/runner/cypress_runner.js:140235:74)\n    at waitForXhr (https://member.daraz.pk/__cypress/runner/cypress_runner.js:151452:12)\n    at &lt;unknown&gt; (https://member.daraz.pk/__cypress/runner/cypress_runner.js:151540:14)\n    at tryCatcher (https://member.daraz.pk/__cypress/runner/cypress_runner.js:18744:23)\n    at MappingPromiseArray._promiseFulfilled (https://member.daraz.pk/__cypress/runner/cypress_runner.js:15864:38)\n    at PromiseArray._iterate (https://member.daraz.pk/__cypress/runner/cypress_runner.js:17066:31)\n    at MappingPromiseArray.init (https://member.daraz.pk/__cypress/runner/cypress_runner.js:17030:10)\n    at MappingPromiseArray._asyncInit (https://member.daraz.pk/__cypress/runner/cypress_runner.js:15833:10)\n    at _drainQueueStep (https://member.daraz.pk/__cypress/runner/cypress_runner.js:13455:12)\n    at _drainQueue (https://member.daraz.pk/__cypress/runner/cypress_runner.js:13444:9)\n    at ../../node_modules/bluebird/js/release/async.js.Async._drainQueues (https://member.daraz.pk/__cypress/runner/cypress_runner.js:13460:5)\n    at Async.drainQueues (https://member.daraz.pk/__cypress/runner/cypress_runner.js:13330:14)\nFrom Your Spec Code:\n    at Context.eval (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazAddCart.feature:15765:12)\n    at Registry.runStepDefininition (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazAddCart.feature:8546:48)\n    at Object.fn (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazAddCart.feature:14973:43)\n    at runStepWithLogGroup (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazAddCart.feature:14607:29)\n    at Context.eval (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazAddCart.feature:14969:62)&quot;,&quot;diff&quot;:null},&quot;uuid&quot;:&quot;09a5d33d-2a6c-4070-b960-9a8bd6ea04d5&quot;,&quot;parentUUID&quot;:&quot;b53e0932-07ca-4cd3-a268-3abe093f7324&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;09a5d33d-2a6c-4070-b960-9a8bd6ea04d5&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:11755,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;e8852721-8f9d-476b-808c-413c5ffd3fe3&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\darazLogin.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\darazLogin.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;402593f1-133d-4f14-94b0-7f4f21b9577f&quot;,&quot;title&quot;:&quot;Daraz Login Feature&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Verify Login Feature with Valid UserName and Password&quot;,&quot;fullTitle&quot;:&quot;Daraz Login Feature Verify Login Feature with Valid UserName and Password&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:28875,&quot;state&quot;:&quot;failed&quot;,&quot;speed&quot;:null,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: Timed out retrying after 4000ms: Expected to find element: `[data-color=\&quot;#7ed321\&quot;] &gt; .card-channels-link`, but never found it.&quot;,&quot;estack&quot;:&quot;AssertionError: Timed out retrying after 4000ms: Expected to find element: `[data-color=\&quot;#7ed321\&quot;] &gt; .card-channels-link`, but never found it.\n    at Context.eval (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:15748:64)\n    at Registry.runStepDefininition (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:8546:48)\n    at Object.fn (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:14973:43)\n    at runStepWithLogGroup (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:14607:29)\n    at Context.eval (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:14969:62)&quot;,&quot;diff&quot;:null},&quot;uuid&quot;:&quot;fe5fe7a3-6598-4321-a933-beadc1add872&quot;,&quot;parentUUID&quot;:&quot;402593f1-133d-4f14-94b0-7f4f21b9577f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;fe5fe7a3-6598-4321-a933-beadc1add872&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:28875,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;1c20adf6-8c90-4a47-91c5-52104295f17a&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\generalNaviagatePages.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\generalNaviagatePages.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;1f46e7c5-28c5-451b-9bcb-442636706668&quot;,&quot;title&quot;:&quot;General Ecommerce Test - Navigate Pages&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Navigate to different Pages from Menu and Verify Contents&quot;,&quot;fullTitle&quot;:&quot;General Ecommerce Test - Navigate Pages Navigate to different Pages from Menu and Verify Contents&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:77793,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;89f17d19-fa56-4e21-8f59-0759a645b17f&quot;,&quot;parentUUID&quot;:&quot;1f46e7c5-28c5-451b-9bcb-442636706668&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;89f17d19-fa56-4e21-8f59-0759a645b17f&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:77793,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;fe3e0264-5d53-4205-995e-0121b127f4b2&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\searchProduct.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\searchProduct.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;bfc9d4bf-111a-4101-8f8a-5c03ab28af52&quot;,&quot;title&quot;:&quot;Search Functionality in eCommerce Website&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Search for a product with price visibility verification&quot;,&quot;fullTitle&quot;:&quot;Search Functionality in eCommerce Website Search for a product with price visibility verification&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:13687,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;6d833217-8651-4dd7-9880-baaade450965&quot;,&quot;parentUUID&quot;:&quot;bfc9d4bf-111a-4101-8f8a-5c03ab28af52&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;6d833217-8651-4dd7-9880-baaade450965&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:13687,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;24fca1b8-54ef-4e15-b8a7-db03b0e2bb11&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\swagLab.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\swagLab.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5edbf180-2e48-48a5-b6c4-b97e5e10d448&quot;,&quot;title&quot;:&quot;End to End Add to Cart in eCommerce&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Ecommerce Add to Cart&quot;,&quot;fullTitle&quot;:&quot;End to End Add to Cart in eCommerce Ecommerce Add to Cart&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:6266,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;c4e47f57-cc4e-445e-a7f5-0d6b1511bd0d&quot;,&quot;parentUUID&quot;:&quot;5edbf180-2e48-48a5-b6c4-b97e5e10d448&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;c4e47f57-cc4e-445e-a7f5-0d6b1511bd0d&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:6266,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;ee888911-4948-4fa2-8889-b6d0533c2536&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\addToCart.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\addToCart.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;d6e5dd38-2d97-430e-9cc3-56befb273a87&quot;,&quot;title&quot;:&quot;Add To Cart - Product&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Select Product, Add To Cart and Verify in Buying Cart&quot;,&quot;fullTitle&quot;:&quot;Add To Cart - Product Select Product, Add To Cart and Verify in Buying Cart&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:51842,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:&quot;{\n  \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-videos-passed\&quot;,\n  \&quot;value\&quot;: \&quot;cypress\\\\e2e\\\\features\\\\addToCart.feature\&quot;\n}&quot;,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;608890b1-ca46-423d-a09c-73dbb1cbe7ce&quot;,&quot;parentUUID&quot;:&quot;d6e5dd38-2d97-430e-9cc3-56befb273a87&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;608890b1-ca46-423d-a09c-73dbb1cbe7ce&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:51842,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;d57d1484-11ce-4a8b-8c01-92d6f83dcc35&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\darazAddCart.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\darazAddCart.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;7fe6b5d2-7ae1-453f-963e-3526580f2f57&quot;,&quot;title&quot;:&quot;Daraz - Add To Cart Feature&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Verify Add To Cart Feature in Daraz&quot;,&quot;fullTitle&quot;:&quot;Daraz - Add To Cart Feature Verify Add To Cart Feature in Daraz&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:52654,&quot;state&quot;:&quot;failed&quot;,&quot;speed&quot;:null,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;context&quot;:&quot;[\n  {\n    \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-videos-failed\&quot;,\n    \&quot;value\&quot;: \&quot;cypress\\\\e2e\\\\features\\\\darazAddCart.feature\&quot;\n  },\n  {\n    \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-screenshots\&quot;,\n    \&quot;value\&quot;: [\n      [\n        \&quot;\\\\darazAddCart.feature\\\\Daraz - Add To Cart Feature -- Verify Add To Cart Feature in Daraz (failed).png\&quot;\n      ]\n    ]\n  }\n]&quot;,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;ReferenceError: UA is not defined&quot;,&quot;estack&quot;:&quot;ReferenceError: UA is not defined\n    at &lt;anonymous&gt;:2:23\n    at i (https://www.daraz.pk/catalog/?q=Hugo+Boss+1513867+Stainless+Steel+Wrist+Watch+for+Men&amp;_keyori=ss&amp;from=input&amp;spm=a2a0e.home.search.go.35e34076Ap9OKX:4:1398)\n    at https://www.daraz.pk/catalog/?q=Hugo+Boss+1513867+Stainless+Steel+Wrist+Watch+for+Men&amp;_keyori=ss&amp;from=input&amp;spm=a2a0e.home.search.go.35e34076Ap9OKX:4:2168\n    at Array.forEach (&lt;anonymous&gt;)\n    at $Cypress.pause (https://www.daraz.pk/catalog/?q=Hugo+Boss+1513867+Stainless+Steel+Wrist+Watch+for+Men&amp;_keyori=ss&amp;from=input&amp;spm=a2a0e.home.search.go.35e34076Ap9OKX:4:2085)&quot;,&quot;diff&quot;:null},&quot;uuid&quot;:&quot;c67c7cac-ffa4-4b77-856a-558601c6a1de&quot;,&quot;parentUUID&quot;:&quot;7fe6b5d2-7ae1-453f-963e-3526580f2f57&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;c67c7cac-ffa4-4b77-856a-558601c6a1de&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:52654,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;b5ab4358-dd69-4f0a-993b-86f1fd714205&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\darazLogin.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\darazLogin.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;2d19c8ff-c690-48d2-862e-dafd4948113d&quot;,&quot;title&quot;:&quot;Daraz Login Feature&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Verify Login Feature with Valid UserName and Password&quot;,&quot;fullTitle&quot;:&quot;Daraz Login Feature Verify Login Feature with Valid UserName and Password&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:50220,&quot;state&quot;:&quot;failed&quot;,&quot;speed&quot;:null,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;context&quot;:&quot;[\n  {\n    \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-videos-failed\&quot;,\n    \&quot;value\&quot;: \&quot;cypress\\\\e2e\\\\features\\\\darazLogin.feature\&quot;\n  },\n  {\n    \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-screenshots\&quot;,\n    \&quot;value\&quot;: [\n      [\n        \&quot;\\\\darazLogin.feature\\\\Daraz Login Feature -- Verify Login Feature with Valid UserName and Password (failed).png\&quot;\n      ]\n    ]\n  }\n]&quot;,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: Timed out retrying after 4000ms: Expected to find element: `[data-color=\&quot;#7ed321\&quot;] &gt; .card-channels-link`, but never found it.&quot;,&quot;estack&quot;:&quot;AssertionError: Timed out retrying after 4000ms: Expected to find element: `[data-color=\&quot;#7ed321\&quot;] &gt; .card-channels-link`, but never found it.\n    at Context.eval (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:15748:64)\n    at Registry.runStepDefininition (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:8546:48)\n    at Object.fn (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:14973:43)\n    at runStepWithLogGroup (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:14607:29)\n    at Context.eval (https://member.daraz.pk/__cypress/tests?p=cypress\\e2e\\features\\darazLogin.feature:14969:62)&quot;,&quot;diff&quot;:null},&quot;uuid&quot;:&quot;549a4b56-e83c-4ac3-b9df-f621d2e79969&quot;,&quot;parentUUID&quot;:&quot;2d19c8ff-c690-48d2-862e-dafd4948113d&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;549a4b56-e83c-4ac3-b9df-f621d2e79969&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:50220,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;597b422c-c1d5-4325-8f01-f75fa1dd6494&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\generalNaviagatePages.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\generalNaviagatePages.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5f17bd2a-d860-4357-84e1-74426f4521d2&quot;,&quot;title&quot;:&quot;General Ecommerce Test - Navigate Pages&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Navigate to different Pages from Menu and Verify Contents&quot;,&quot;fullTitle&quot;:&quot;General Ecommerce Test - Navigate Pages Navigate to different Pages from Menu and Verify Contents&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:66946,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:&quot;{\n  \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-videos-passed\&quot;,\n  \&quot;value\&quot;: \&quot;cypress\\\\e2e\\\\features\\\\generalNaviagatePages.feature\&quot;\n}&quot;,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;1f0cb77e-c274-4a05-b7c0-16c458769482&quot;,&quot;parentUUID&quot;:&quot;5f17bd2a-d860-4357-84e1-74426f4521d2&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;1f0cb77e-c274-4a05-b7c0-16c458769482&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:66946,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;82a52323-fa4d-44a6-9aaa-37647b454d28&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\searchProduct.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\searchProduct.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;2e6737e4-674a-4fdf-bb60-8ee47f02618f&quot;,&quot;title&quot;:&quot;Search Functionality in eCommerce Website&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Search for a product with price visibility verification&quot;,&quot;fullTitle&quot;:&quot;Search Functionality in eCommerce Website Search for a product with price visibility verification&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:6135,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:&quot;{\n  \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-videos-passed\&quot;,\n  \&quot;value\&quot;: \&quot;cypress\\\\e2e\\\\features\\\\searchProduct.feature\&quot;\n}&quot;,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;9c792362-e2e4-4018-aa69-a2466819c88b&quot;,&quot;parentUUID&quot;:&quot;2e6737e4-674a-4fdf-bb60-8ee47f02618f&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;9c792362-e2e4-4018-aa69-a2466819c88b&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:6135,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;23732a4e-e2c5-460f-bfe6-cd05be4acb70&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\swagLab.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\swagLab.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;600ef631-0b28-4e9f-9a54-a186de24729a&quot;,&quot;title&quot;:&quot;End to End Add to Cart in eCommerce&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Ecommerce Add to Cart&quot;,&quot;fullTitle&quot;:&quot;End to End Add to Cart in eCommerce Ecommerce Add to Cart&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:5104,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;medium&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:&quot;{\n  \&quot;title\&quot;: \&quot;cypress-mochawesome-reporter-videos-passed\&quot;,\n  \&quot;value\&quot;: \&quot;cypress\\\\e2e\\\\features\\\\swagLab.feature\&quot;\n}&quot;,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;24adaaec-8b7f-44f8-b8f1-b9c36c06f523&quot;,&quot;parentUUID&quot;:&quot;600ef631-0b28-4e9f-9a54-a186de24729a&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;24adaaec-8b7f-44f8-b8f1-b9c36c06f523&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:5104,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;ef1756ca-5fd2-4fd3-b503-65f3237cbdc7&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress\\e2e\\features\\addToCart.feature&quot;,&quot;file&quot;:&quot;cypress\\e2e\\features\\addToCart.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;5dd29819-c4df-4075-8108-1aba240d49af&quot;,&quot;title&quot;:&quot;Add To Cart - Product&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Select Product, Add To Cart and Verify in Buying Cart&quot;,&quot;fullTitle&quot;:&quot;Add To Cart - Product Select Product, Add To Cart and Verify in Buying Cart&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:54916,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;slow&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a2, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\ntaskTestCaseStarted(context, {\n  id: testCaseStartedId,\n  testCaseId,\n  attempt: attempt++,\n  timestamp: (0, messages_1.createTimestamp)()\n});\nwindow.testState = {\n  gherkinDocument,\n  pickles,\n  pickle\n};\nfor (const step of steps) {\n  if (step.hook) {\n    const hook = step.hook;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: hook.id\n    });\n    cy.then(() =&gt; {\n      delete window.testState.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      (0, cypress_1.runStepWithLogGroup)({\n        fn: () =&gt; registry2.runHook(this, hook),\n        keyword: hook.keyword,\n        text: hook.tags\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const end = (0, messages_1.createTimestamp)();\n      taskTestStepFinished(context, {\n        testStepId,\n        testCaseStartedId,\n        testStepResult: {\n          status: messages.TestStepResultStatus.PASSED,\n          duration: (0, messages_1.duration)(start, end)\n        },\n        timestamp: end\n      });\n      remainingSteps.shift();\n    });\n  } else if (step.pickleStep) {\n    const pickleStep = step.pickleStep;\n    const testStepId = getTestStepId({\n      context,\n      pickleId: pickle.id,\n      hookIdOrPickleStepId: pickleStep.id\n    });\n    const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n    const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a2 = pickleStep.astNodeIds) === null || _a2 === void 0 ? void 0 : _a2[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n    const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable) ? new data_table_1.default(pickleStep.argument.dataTable) : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content) ? pickleStep.argument.docString.content : void 0;\n    cy.then(() =&gt; {\n      window.testState.pickleStep = step.pickleStep;\n      const start = (0, messages_1.createTimestamp)();\n      internalProperties.currentStep = { pickleStep };\n      internalProperties.currentStepStartedAt = start;\n      taskTestStepStarted(context, {\n        testStepId,\n        testCaseStartedId,\n        timestamp: start\n      });\n      return cy.wrap(start, { log: false });\n    }).then((start) =&gt; {\n      const beforeStepHooks = registry2.resolveBeforeStepHooks(tags);\n      const afterStepHooks = registry2.resolveAfterStepHooks(tags);\n      const options = {\n        pickle,\n        pickleStep,\n        gherkinDocument,\n        testCaseStartedId,\n        testStepId\n      };\n      const beforeHooksChain = beforeStepHooks.reduce((chain, beforeStepHook) =&gt; {\n        return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n          keyword: \&quot;BeforeStep\&quot;,\n          text: beforeStepHook.tags,\n          fn: () =&gt; registry2.runStepHook(this, beforeStepHook, options)\n        }));\n      }, cy.wrap({}, { log: false }));\n      return beforeHooksChain.then(() =&gt; {\n        try {\n          return (0, cypress_1.runStepWithLogGroup)({\n            keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n            argument,\n            text,\n            fn: () =&gt; registry2.runStepDefininition(this, text, argument)\n          }).then((result) =&gt; {\n            return afterStepHooks.reverse().reduce((chain, afterStepHook) =&gt; {\n              return chain.then(() =&gt; (0, cypress_1.runStepWithLogGroup)({\n                keyword: \&quot;AfterStep\&quot;,\n                text: afterStepHook.tags,\n                fn: () =&gt; registry2.runStepHook(this, afterStepHook, options)\n              }));\n            }, cy.wrap({}, { log: false })).then(() =&gt; {\n              return { start, result };\n            });\n          });\n        } catch (e) {\n          if (e instanceof registry_1.MissingDefinitionError) {\n            throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n          } else {\n            throw e;\n          }\n        }\n      });\n    }).then(({ start, result }) =&gt; {\n      var _a3, _b2, _c2;\n      const end = (0, messages_1.createTimestamp)();\n      if (result === \&quot;pending\&quot;) {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PENDING,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n        for (const skippedStep of remainingSteps) {\n          const hookIdOrPickleStepId = (0, assertions_1.assertAndReturn)((_b2 = (_a3 = skippedStep.hook) === null || _a3 === void 0 ? void 0 : _a3.id) !== null &amp;&amp; _b2 !== void 0 ? _b2 : (_c2 = skippedStep.pickleStep) === null || _c2 === void 0 ? void 0 : _c2.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n          const testStepId2 = getTestStepId({\n            context,\n            pickleId: pickle.id,\n            hookIdOrPickleStepId\n          });\n          taskTestStepStarted(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n          taskTestStepFinished(context, {\n            testStepId: testStepId2,\n            testCaseStartedId,\n            testStepResult: {\n              status: messages.TestStepResultStatus.SKIPPED,\n              duration: {\n                seconds: 0,\n                nanos: 0\n              }\n            },\n            timestamp: (0, messages_1.createTimestamp)()\n          });\n        }\n        for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n          remainingSteps.pop();\n        }\n        cy.then(() =&gt; this.skip());\n      } else {\n        taskTestStepFinished(context, {\n          testStepId,\n          testCaseStartedId,\n          testStepResult: {\n            status: messages.TestStepResultStatus.PASSED,\n            duration: (0, messages_1.duration)(start, end)\n          },\n          timestamp: end\n        });\n        remainingSteps.shift();\n      }\n    });\n  }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d9cfa503-b462-4341-99c7-3533a8872687&quot;,&quot;parentUUID&quot;:&quot;5dd29819-c4df-4075-8108-1aba240d49af&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d9cfa503-b462-4341-99c7-3533a8872687&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:54916,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;7.0.1&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:false,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.3&quot;},&quot;marge&quot;:{&quot;options&quot;:{&quot;charts&quot;:true,&quot;reportPageTitle&quot;:&quot;custom-title&quot;,&quot;embeddedScreenshos&quot;:true,&quot;inlineAssets&quot;:true,&quot;saveAllAttempts&quot;:false,&quot;reportDir&quot;:&quot;cypress/results&quot;,&quot;overwrite&quot;:false,&quot;html&quot;:false,&quot;json&quot;:true},&quot;version&quot;:&quot;6.2.0&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;output1&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;cypress_BDD_cucumber&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:false,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report\\assets&quot;,&quot;htmlFile&quot;:&quot;C:\\automation_project\\cypress_BDD_cucumber\\mochawesome-report\\output1.html&quot;}"><div id="report"></div><script src="assets\app.js"></script></body></html>